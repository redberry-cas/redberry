/*
 * Redberry: symbolic tensor computations.
 *
 * Copyright (c) 2010-2012:
 *   Stanislav Poslavsky   <stvlpos@mail.ru>
 *   Bolotin Dmitriy       <bolotin.dmitriy@gmail.com>
 *
 * This file is part of Redberry.
 *
 * Redberry is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Redberry is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Redberry. If not, see <http://www.gnu.org/licenses/>.
 */
package cc.redberry.core.combinatorics;

import java.util.*;

/**
 * This class is a representation of {@link Symmetry} set. It holds a set of
 * symmetries and provides common functionality: adding {@code Symmetry} and
 * iterating over all possible symmetries, which can be generated by
 * compositions of keeping symmetries. Also, it watches that all keeping
 * symmetries are consistent, i.e. it throws {@link InconsistentGeneratorsException}
 * when trying to add symmetry, which is inconsistent with already added
 * symmetries. All adding combinatorics must have the same dimension, which
 * specified at initialization. For more details see method summary.
 *
 * @see Symmetry
 * @see PermutationsSpanIterator
 *
 * @author Dmitry Bolotin
 * @author Stanislav Poslavsky
 */
class SymmetriesImpl implements Symmetries {

    private final List<Symmetry> symmetries;
    private final int dimension;

    /**
     * Create {@code SymmetriesImpl}, which contains symmetries with specified
     * dimension. The symmetries set will contain now single identity symmetry
     * with specified dimension.
     *
     * @param dimension dimension of combinatorics in this symmetries set
     */
    SymmetriesImpl(int dimension) {
        this.dimension = dimension;
        this.symmetries = new ArrayList<>();
        this.symmetries.add(new Symmetry(dimension));
    }

    private SymmetriesImpl(List<Symmetry> list, int dimension) {
        this.dimension = dimension;
        this.symmetries = list;
    }

    @Override
    public int dimension() {
        return dimension;
    }

    /**
     * Appends the specified {@code Symmetry} to this {@code SymmetriesImpl}. If
     * inconsistent {@code Symmetry} adding it throws
     * {@code InconsistentGeneratorsException}. Note, that some times it is
     * difficult for human to understand that adding symmetry is inconsistent.
     *
     * <h4><a name="SymmetriesImpl">Examples:</a></h4> Trying to add {@code new Symmetry(new int[]{0,1,2},true)},
     * i.e. identical permutation which change sign, will throws. <p> Assume, we
     * have already added {@code new Symmetry(new int[]{0,2,1},false)}, which is
     * transposition of the second and the third element. If the we try to add {@code new Symmetry(new int[]{0,2,1},true)},
     * which is the same transposition, but changing sign, this method will
     * throws. <p> More difficult example: adding {@code new Symmetry(new int[]{2,0,1},true)}
     * will throws. Discover, what's wrong here?
     *
     * @param symmetry {@code Symmetry} to be added
     *
     * @throws InconsistentGeneratorsException if adding {@code Symmetry} is
     * inconsistent with already added symmetries
     */
    @Override
    public boolean add(Symmetry symmetry) throws InconsistentGeneratorsException {
        if (symmetry.dimension() != dimension)
            throw new IllegalArgumentException();
        PermutationsSpanIterator<Symmetry> it = new PermutationsSpanIterator<>(symmetries);
        //BOTTLENECK review
        while (it.hasNext()) {
            Symmetry s = it.next();
            if (s.equals(symmetry))
                return false;
        }
        symmetries.add(symmetry);
        checkSymmetryConsistent();
        return true;
    }

    /**
     * Appends the specified array of {@code Symmetry} to this {@code SymmetriesImpl}.
     * If inconsistent {@code Symmetry} adding it throws
     * {@code InconsistentGeneratorsException}. Note, that some times it is
     * difficult for human to understand that adding symmetry is inconsistent.
     *
     * <h4><a name="SymmetriesImpl">Examples:</a></h4> Trying to add {@code new Symmetry(new int[]{0,1,2},true)},
     * i.e. identical permutation which change sign, will throws. <p> Assume, we
     * have already added {@code new Symmetry(new int[]{0,2,1},false)}, which is
     * transposition of the second and the third element. If the we try to add {@code new Symmetry(new int[]{0,2,1},true)},
     * which is the same transposition, but changing sign, this method will
     * throws. <p> More difficult example: adding {@code new Symmetry(new int[]{2,0,1},true)}
     * will throws. Discover, what's wrong here?
     *
     * @param symmetry {@code Symmetry} to be added
     *
     * @throws InconsistentGeneratorsException if adding {@code Symmetry} is
     * inconsistent with already added symmetries
     */
    @Override
    public boolean addAll(Symmetry... symmetries) throws InconsistentGeneratorsException {
        if (symmetries.length == 0)
            return false;
        for (Symmetry s : symmetries)
            if (s.permutation.length != dimension)
                throw new IllegalArgumentException("Dimension of adding symmetry is deffers from this one.");

        PermutationsSpanIterator<Symmetry> it;
        boolean added = false;
        OUT:
        for (Symmetry sym : symmetries) {
            it = new PermutationsSpanIterator<>(this.symmetries);
            //BOTTLENECK review
            while (it.hasNext()) {
                Symmetry s = it.next();
                if (s.equals(sym))
                    continue OUT;
            }
            this.symmetries.add(sym);
            added = true;
        }
        return added;
    }

    /**
     * Appends the specified array of {@code Symmetry} to this {@code SymmetriesImpl}.
     * If inconsistent {@code Symmetry} adding it throws
     * {@code InconsistentGeneratorsException}. Note, that some times it is
     * difficult for human to understand that adding symmetry is inconsistent.
     *
     * <h4><a name="SymmetriesImpl">Examples:</a></h4> Trying to add {@code new Symmetry(new int[]{0,1,2},true)},
     * i.e. identical permutation which change sign, will throws. <p> Assume, we
     * have already added {@code new Symmetry(new int[]{0,2,1},false)}, which is
     * transposition of the second and the third element. If the we try to add {@code new Symmetry(new int[]{0,2,1},true)},
     * which is the same transposition, but changing sign, this method will
     * throws. <p> More difficult example: adding {@code new Symmetry(new int[]{2,0,1},true)}
     * will throws. Discover, what's wrong here?
     *
     * @param symmetry {@code Symmetry} to be added
     *
     * @throws InconsistentGeneratorsException if adding {@code Symmetry} is
     * inconsistent with already added symmetries
     */
    @Override
    public boolean addAll(Collection<Symmetry> symmetries) throws InconsistentGeneratorsException {
        if (symmetries.isEmpty())
            return false;
        for (Symmetry s : symmetries)
            if (s.permutation.length != dimension)
                throw new IllegalArgumentException("Dimension of adding symmetry is deffers from this one.");

        PermutationsSpanIterator<Symmetry> it;
        boolean added = false;
        OUT:
        for (Symmetry sym : symmetries) {
            it = new PermutationsSpanIterator<>(this.symmetries);

            //BOTTLENECK review
            while (it.hasNext()) {
                Symmetry s = it.next();
                if (s.equals(sym))
                    continue OUT;
            }
            this.symmetries.add(sym);
            added = true;
        }
        return added;
    }

    //TODO comment
    @Override
    public boolean addUnsafe(Symmetry symmetry) {
        if (symmetry.permutation.length != dimension)
            throw new IllegalArgumentException("Not equal dimensions.");
        for (Symmetry s : symmetries)
            if (s.equals(symmetry))
                return false;
        symmetries.add(symmetry);
        return true;
    }

    //TODO comment
    @Override
    public boolean addAllUnsafe(Symmetry... symmetries) {
        for (Symmetry s : symmetries)
            if (s.permutation.length != dimension)
                throw new IllegalArgumentException("Not equal dimensions.");
        boolean b = false;
        OUT:
        for (Symmetry add : symmetries) {
            for (Symmetry s : this.symmetries)
                if (s.equals(add))
                    continue OUT;
            this.symmetries.add(add);
            b = true;
        }
        return b;
    }

    //TODO comment
    @Override
    public boolean addAllUnsafe(Collection<Symmetry> symmetries) {
        for (Symmetry s : symmetries)
            if (s.permutation.length != dimension)
                throw new IllegalArgumentException("Not equal dimensions.");
        boolean b = false;
        OUT:
        for (Symmetry add : symmetries) {
            for (Symmetry s : this.symmetries)
                if (s.equals(add))
                    continue OUT;
            this.symmetries.add(add);
            b = true;
        }
        return b;
    }

    //TODO comment
    @Override
    public boolean addAllUnsafe(Symmetries symmetries) {
        if (symmetries instanceof SymmetriesImpl)
            return addAllUnsafe(((SymmetriesImpl) symmetries).symmetries);
        throw new IllegalArgumentException("Inconsistent dimension.");
    }

    /**
     * Appends the specified {@code Symmetry}, which is represented by its
     * permutation array in one-line notation and boolean sign, to this {@code SymmetriesImpl}.
     * If inconsistent {@code Symmetry} adding it throws
     * {@code InconsistentGeneratorsException}. Note, that some times it is
     * difficult for human to understand that adding symmetry is inconsistent.
     *
     * <h4><a name="SymmetriesImpl">Examples:</a></h4> Trying to add {@code new Symmetry(new int[]{0,1,2},true)},
     * i.e. identical permutation which change sign, will throws. <p> Assume, we
     * have already added {@code new Symmetry(new int[]{0,2,1},false)}, which is
     * transposition of the second and the third element. If the we try to add {@code new Symmetry(new int[]{0,2,1},true)},
     * which is the same transposition, but changing sign, this method will
     * throws. <p> More difficult example: adding {@code new Symmetry(new int[]{2,0,1},true)}
     * will throws. Discover, what's wrong here?
     *
     * @param symmetry {@code Symmetry} permutation in one-line notation to be
     * added
     * @param sign     {@code Symmetry} sign
     *
     * @throws InconsistentGeneratorsException if adding {@code Symmetry} is
     * inconsistent with already added symmetries
     */
    @Override
    public boolean add(boolean sign, int... symmetry) throws InconsistentGeneratorsException {
        return add(new Symmetry(symmetry, sign));
    }

    /**
     * Returns an iterator over the set of {@code Symmetry} in this class and
     * all different symmetries, which can be produced by all compositions of
     * them. It returns an instance of
     * {@code PermutationsSpanIterator}, and for more details look its
     * documentation.
     *
     * @return Returns an iterator over the set of {@code Symmetry} in this
     * class and all different symmetries, which can be produced by all
     * compositions of them.
     *
     * @see PermutationsSpanIterator
     */
    @Override
    public Iterator<Symmetry> iterator() {
        return new PermutationsSpanIterator<>(symmetries);
    }

    @Override
    public boolean isEmpty() {
        return false;
    }

    @Override
    public List<Symmetry> getBaseSymmetries() {
        return Collections.unmodifiableList(symmetries);
    }

    protected void checkSymmetryConsistent() throws InconsistentGeneratorsException {
        PermutationsSpanIterator<Symmetry> it = new PermutationsSpanIterator<>(symmetries);
        while (it.hasNext())
            it.next();
    }

    @Override
    public SymmetriesImpl clone() {
        return new SymmetriesImpl(new ArrayList<>(symmetries), dimension);
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        for (Symmetry s : symmetries)
            sb.append(s.toString()).append("\n");
        return sb.toString();
    }

    public static Symmetries getFullSymmetries(int dimension) {
        if (dimension < 0)
            throw new IllegalArgumentException();
        if (dimension <= 1)
            return SymmetriesFactory.createSymmetries(dimension);
        SymmetriesImpl symmetries = new SymmetriesImpl(dimension);

        //transposition
        int[] transposition = new int[dimension];
        transposition[1] = 0;
        transposition[0] = 1;
        int i;
        for (i = 2; i < dimension; ++i)
            transposition[i] = i;
        Symmetry transpositionSymmetry = new Symmetry(transposition, false);

        //cycle
        int[] cycle = new int[dimension];
        cycle[0] = dimension - 1;
        for (i = 1; i < dimension; ++i)
            cycle[i] = i - 1;

        Symmetry cycleSymmetry = new Symmetry(cycle, false);
        symmetries.addUnsafe(cycleSymmetry);
        symmetries.addUnsafe(transpositionSymmetry);
        return symmetries;
    }

    public static Symmetries getFullSymmetriesForSortedIndices(int upperCount, int lowerCount) {
        if (upperCount < 0 || upperCount < 0)
            throw new IllegalArgumentException();
        if (upperCount + lowerCount <= 1)
            return SymmetriesFactory.createSymmetries(upperCount + lowerCount);

        SymmetriesImpl symmetries = new SymmetriesImpl(upperCount + lowerCount);

        //transposition
        int i;
        if (upperCount > 1) {
            int[] upperTransposition = createIdentity(upperCount + lowerCount);
            upperTransposition[0] = 1;
            upperTransposition[1] = 0;
            Symmetry upperTranspositionSymmetry = new Symmetry(upperTransposition, false);
            symmetries.addUnsafe(upperTranspositionSymmetry);
        }

        if (lowerCount > 1) {
            int[] lowerTransposition = createIdentity(upperCount + lowerCount);
            lowerTransposition[upperCount] = 1 + upperCount;
            lowerTransposition[upperCount + 1] = upperCount;
            Symmetry lowerTranspositionSymmetry = new Symmetry(lowerTransposition, false);
            symmetries.addUnsafe(lowerTranspositionSymmetry);
        }

        //cycle        
        if (upperCount > 2) {
            int[] upperCycle = new int[upperCount + lowerCount];
            upperCycle[0] = upperCount - 1;
            for (i = 1; i < upperCount; ++i)
                upperCycle[i] = i - 1;
            for (; i < upperCount + lowerCount; ++i)
                upperCycle[i] = i;
            Symmetry upperCycleSymmetry = new Symmetry(upperCycle, false);
            symmetries.addUnsafe(upperCycleSymmetry);
        }
        if (lowerCount > 2) {
            int[] lowerCycle = new int[upperCount + lowerCount];
            for (i = 0; i < upperCount; ++i)
                lowerCycle[i] = i;
            lowerCycle[upperCount] = upperCount + lowerCount - 1;
            ++i;
            for (; i < upperCount + lowerCount; ++i)
                lowerCycle[i] = i - 1;
            Symmetry lowerCycleSymmetry = new Symmetry(lowerCycle, false);
            symmetries.addUnsafe(lowerCycleSymmetry);
        }

        return symmetries;
    }

    private static int[] createIdentity(int dimension) {
        int[] n = new int[dimension];
        for (int i = 1; i < dimension; ++i)
            n[i] = i;
        return n;
    }
}
